const fs = require('fs')
const path = require('path')
const prettier = require('prettier')
const YAML = require('yaml')

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

function collectUniqueValues(obj) {
  let values = []
  for (const key in obj) {
    const value = obj[key].set
    if (typeof value === 'string') {
      values.push(value)
    } else if (Array.isArray(value)) {
      values = values.concat(value)
    }
  }
  return [...new Set(values)]
}

function genPreset(preset) {
  const properties = collectUniqueValues(preset.channels)

  const definition = {
    type: 'object',
    $extends: 'Preset',
    properties: {}
  }

  for (let i = 0; i < properties.length; i++) {
    const propertyName = properties[i]
    definition.properties[propertyName] = {
      oneOf: [{ type: 'array', items: { type: 'string' } }, { type: 'string' }]
    }
    definition.required = definition.required || []
    definition.required.push(propertyName)
  }

  return definition
}

function genPresetClass(presets) {
  const definition = {
    type: 'object',
    description: 'Collection of factory functions for creating preset chart configs.',
    properties: {}
  }
  for (const name in presets) {
    const methodName = name
    const parameterType = capitalize(name)
    definition.properties[methodName] = {
      type: 'function',
      arguments: {
        config: {
          $ref: parameterType
        }
      },
      return: {
        $ref: 'config/Chart'
      },
      required: ['config']
    }
  }
  return definition
}

function genSchema(presets) {
  const schema = {
    definitions: {
      Preset: {
        type: 'object',
        properties: {
          legend: {
            type: 'string',
            enum: ['color', 'lightness', 'size'],
            nullable: true
          },
          title: {
            type: 'string',
            nullable: true
          },
          subtitle: {
            type: 'string',
            nullable: true
          },
          caption: {
            type: 'string',
            nullable: true
          },
          reverse: {
            type: 'boolean'
          },
          sort: {
            type: 'string',
            enum: ['none', 'byValue']
          }
        }
      }
    }
  }

  for (const presetName in presets) {
    schema.definitions[capitalize(presetName)] = genPreset(presets[presetName])
  }
  schema.definitions.Presets = genPresetClass(presets)

  return schema
}

async function writeSchema(schema, outputPath) {
  console.log('Writing to ' + outputPath)

  const warningText = `
# This file is auto-generated by preset-typeschema-gen.js
# Do not edit this file directly.
# Instead, edit the presets in src/apps/weblib/js-api/plugins/presets.js
# and run tools/preset-typeschema-gen to regenerate this file.
`

  const content = warningText + YAML.stringify(schema, null, 2)
  const formattedContent = await prettier.format(content, {
    parser: 'yaml',
    tabWidth: 2
  })
  fs.writeFileSync(outputPath, formattedContent)
}

let presetPath = process.argv[2]
let outputPath = process.argv[3]

if (!presetPath) presetPath = path.join(__dirname, '../../..', 'src/apps/weblib/js-api/plugins/presets.js')
if (!outputPath)
  outputPath = path.join(__dirname, '../../..', 'src/apps/weblib/typeschema-api/presets.yaml')

import(presetPath)
  .then((PresetsModule) => {
    const Presets = PresetsModule.default
    const presets = new Presets()._presetConfigs
    const schema = genSchema(presets)
    return writeSchema(schema, outputPath)
  })
  .catch((err) => {
    console.error(err)
  })
